.TH MDSC "1" "January 2005" "ADS"
.SH NAME
mdsc: The MDS Core system
.SH SYNOPSIS
.BI mdsc::memobj " command arg1 arg2 ..."
.BR

.BI mdsc::copy " command arg1 arg2 ..."
.SH DESCRIPTION
.PP
.\" Add any additional description here
.PP
The \fImdsc::memobj\fR command is used to create, destroy and manipulate
\fImemory objects\fR. A \fImemory object\fR is more or less
a main memory buffer containing binary data.
The \fImdsc::copy\fR command implements a asynchronous copy
from a memory object to a channel and vice versa.

.SH "mdsc::memobj COMMAND"
This command has the following forms:
.TP
.BI "mdsc::memobj create" 
Creates a new (empty) memory object and returns a handle to it.
This handle should be used when calling the other commands to manipulate
this object.
.TP
.BI "mdsc::memobj delete " handle
This command deletes the memory object specified by the given handle.
If this handle is used again in a memory object command an error will occur.
All memory occupied by the object is freed.
.TP
.BI "mdsc::memobj exists " handle
Return 1 if the given handle is a valid memory object handle, 0 otherwise.
.TP
.BI "mdsc::memobj size " handle
This command returns the size of the object (number of bytes)
.TP
.BI "mdsc::memobj clear " handle
This commands clears the data of the object with the given handle.
All previous data are lost, memory is freed, and the object has now
zero size.
.TP
.BI "mdsc::memobj md5sum " handle
Return the md5 checksum of the object (as a string of 32 hex digits)
.TP
.BI "mdsc::memobj append " "handle string ?start ?nbytes??
Append to any data the object already has the bytes of the given (binary)
string. Normally the whole string is appended to the object's data.
However it is possible to append only a part of the string.
The \fIstart\fR optional argument specifies the offset of the first
byte to copy (default is zero) or to put it in another way the number
of bytes to skip copying. The \fInbytes\fR optional argument specifies
how many bytes to copy. If negative, then it means that we should copy
all the remaining bytes of the string (default value is -1).
If the value of the \fIstart\fR argument is greater than the size of the
object, then no bytes are copied.
If the value of the \fInbytes\fR argument is non negative and
\fIstart + nbytes\fR is greater than the size of the string, then only
\fIstring length - start\fR bytes are copied.
This command returns the total number of bytes appended to the object
.TP
.BI "mdsc::memobj get " "handle ?start ?nbytes??
Return (as a binary string) the data contained in the object.
The optional \fIstart\fR and \fInbytes\fR arguments have similar
meaning as in the \fIappend\fR command. If not specified, then the
\fBentire\fR object is returned.
.TP
.BI "mdsc::memobj list"
Returns a list with all the valid memory object handles
.TP
.BI "mdsc::memobj load " "handle filename"
Load the data of a memory object from a file.
All previous content is erased.
Note that this is a simple synchronous file read, meaning that we block
until the object is completely read from the file.
It has nothing to do with the much more efficient and elaborate
\fImdsc::copy\fR command.
It is mainly used for debugging.
.TP
.BI "mdsc::memobj store " "handle filename"
Store the data of a memory object to a file.
Note that this is a simple synchronous file write, meaning that we block
until the object is written to the file.
It has nothing to do with the much more efficient and elaborate
\fImdsc::copy\fR command and is mainly used for debugging.
.TP
.BI "mdsc::memobj random " "handle size ?seed?"
Populate an object with some random data.
The \fIsize\fR is the new size of the object and \fIseed\fR is the
seed to be used in the random number generator.
As you might have already guessed, this command
is used for testing and debugging and nothing else!

.SH "mdsc::copy COMMAND"
This command has the following forms:
.TP
.BI "mdsc::copy to " "handle channel ?options?"
Asynchronously copy the data from an object to an (already open) channel.
It returns a unique handle that can be used to identify this copy
operation to subsequent calls to the \fImdsc::copy info\fR and
\fImdsc::copy forget\fR commands.
Valid options are:
.TP
.BI "-start"
This option specifies the offset of the first byte of the object to copy
(or to put it in another way, the number of bytes to skip). Default is zero.
.TP
.BI "-nbytes"
This option specifies how many bytes to copy. If negative, then we copy
all the bytes till the end of the object.
.TP
.BI "-buffersize"
The buffer size to use in the channel. More or less we just do
a \'fconfigure $channel -buffersize $value\'.
.TP
.BI "-chunksize"
During the copy operation, we read a chunk of data from the object,
write it to the channel, and then repeat this until we copy all the
bytes.
This option specifies the size of this chunk.
Default size is 1 megabyte.
.TP
.BI "-callback"
This option specifies a command to be called when the copy completes,
or intermediatelly during the copy operation (see the \fI-statusevery\fR
option below)
A single argument is appended to the callback given. It is a list
with attribute/values (suitable for \'array set ...\')
that contains information about the copy.
The most interesting attributes are \fIstatus\fR (one of \fIrun\fR, \fIok\fR,
and \fIerror\fR), \fIerror\fR (an error message, iff \fIstatus\fR is
equal to \fIerror\fR), \fIncopied\fR (number of bytes copied),
\fItstart\fR and \fItlast\fR (time the copy started, and time this information
was last updated).
.TP
.BI "-statusevery"
If non zero, then every time that many bytes are copied we call the
command specified with the \fI-callback\fR option. In this case the
\fIstatus\fR attribute will have the value \fIrun\fR.
Note that this number is just a hint, and there is no guarantee that
the callback will be called as often as this option specifies
(to be more precise, we check whether we should call the callback
after each chunk is copied, so it makes no sense for the \fI-statusevery\fR
option to be less than the value of \fI-chunksize\fR option)
.TP
.BI "-autoforget"
If this option has a true value (the default),
then when the copy is finished
and the callback (if any) has been called, the system will
forget everything about this copy operation (so you will not be able
to query the status of the copy with the \fImdsc::copy info\fR command)
If the value is false, then you will have to 
explicitly call \fImdsc::copy forget...\fR.

NOTE: The options that require a number of bytes accept integers,
that are optionally followed by the letters \fIk\fR (for kilobytes)
or \fIm\fR (for megabytes)

.TP
.BI "mdsc::copy from " "handle channel ?options?"
Asynchronously copy the data from an (already open) channel
to an object.
It accepts the same options as the \fImdsc::copy to\fR command, with
the following variations:
The \fI-start\fR option specifies how many bytes to ignore when reading
from the channel.
If \fI-nbytes\fR is negative, then we will read up to EOF, while if it
is positive we will read up to that number of bytes (or up to EOF, whichever
comes first). Note that it is not considered an error to reach EOF
before the specified number of bytes is read.

.TP
.BI "mdsc::copy info " "?handle?"
If called with no arguments, it returns the handles of all copy operations
known to the system. Else it returns information about the copy operation
specified by the given handle.
This information is exactly the same as the information passed to the
callback specified with the \fI-callback\fR command.
NOTE: This information is only updated every time the callback is called.
So unless you have specified a non zero value for the \fI-statusevery\fR
option, you will not get any useful information until the copy completes.

.TP
.BI "mdsc::copy forget " "handle"
Forget a copy operation that had the \fI-autoforget\fR option set to
false.

.SH "SEMANTICS"
The memory object handles are \fIglobal\fR to all interpreters.
I.e. a memory object created by an interpreter is visible and can be
used automatically by any other interpreter (or thread).
All the \fImdsc::memobj ...\fR commands are thread safe.
The copy handles are known only to the interpreter that started them.
