MSH API in zroute

The command:
	spawn t script

will start script on the remote node, the task being named as "t"
The command:

	monitor t {
		done { parray task }
	}

will monitor task t

currently, the array variable task contains:

task(task):   the name of the task as given to task command
task(id):     the internal (MSH) id of the task
task(status): the state of the task

task(output): the entire stdout produced by the remote job
task(error):  if no empty, it indicates that the evaluation of the script
              produced errors. task(errorInfo) shows the stack trace
task(return): the return value of the script evaluated in the remote node
task(sema)  : to exit the monitor loop using: $task(sema) Signal

See examples/msh/msh1.tcl
-----------------------------------------------------------------------------
MDS ARCHITECTURE

MDS is simply a client for publish and subscribe methods.

Clients that wish to support publish & subscribe, they simply do:

% mds::init mds://localhost:6370

to connect to an mds instance running on port 6370 of localhost

after that, they can use the publish & subscribe commands, as follows:

# export mds commands
% mds::export

% Publish set1   ;# publish a data set
% Subscribe set1 ;# subscribe to a data set

The return value in both cases are objects representing the data sets
being shared. Additional functionality is offerred trhough those objects

A peer to peer facility has been added and works as follows:

% Publish -p2p 1 set1
% Subscribe -p2p 1 set1

Those two commands allow the socket transfer to take place directly
between the publisher and the subscriber. In this case the MDS server
is not contacted. Otherwise the semantics of pub/sub are maintained,
including multiple subscribers. The exception is that successive
subscriptions will cause the publisher send the data set, which may
have changed in the mean time. In the case of MDS, the data set
is cached on MDS and only retrieved once from the publisher.

NOTE: the -p2p option on the Subscriber is probably reduntant, and could
be ommitted in the future. Currently, if -p2p is not specified, it defaults
to 0.

-------------------------------------------------------------------------------
# RSLAVE

RSlave is a facility to execute multiple remote commands on a slave,
in contrast to the single command "spawn" allows.

Usage:

1. Define two classes derived from ADSProxy
and ADSSlave respectively (say DemoProxy and DemoSlave). It is important
that both classes have the same name prefix.

2. Store the defininition of DemoProxy and DemoSlave on a file called
demo.tcl

3. Instantiate the local proxy:
    DemoProxy p -init "source demo.tcl" -async 1
In this case async 1 allows for asynchronous connection of the remote end.

4. A handler for the remote connection event could be established:
   p Bind <<connected>> my_connected_handler

5. Force the local proxy to schedule a remote slave to run:
   p StartRemote
If async was not set to 1, then, p StartRemote will block waiting
for the remote slave to be allocated and get connected with us.

6. Use p Send to execute any remote command from home to the remote.

For more examples look at examples/rslave.tcl
