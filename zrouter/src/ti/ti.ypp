%{
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <assert.h>
#include "ti.h"
#include "ti_parser.hpp"

void Tierror( const char * msg );
int Tilex();
int Tierrors = 0;
int ignore_error = false;
const char * Tiinfile;
extern char * Titext;
extern char Ticcode[8192];
extern int Tilex_lineno;

Module * cur_module = NULL;
Member * cur_member = NULL;
Method * cur_method = NULL;
Arg * cur_arg = NULL;
Var * cur_var = NULL;

Var * findVar( std::list<Var *> & vars, const char * var_name );
Arg * findArg( std::list<Arg *> & args, const char * arg_name );
Method * findMethod( std::list<Method *> & methods, const char * name );

void module( const char * name, const char * zname )
{
    cur_module = new Module(name, zname); 
    modules.push_back(cur_module);
}

void method( const char * name, const char * zcmd )
{
    if ( strcmp(zcmd, "delete") == 0 )
        Tierror("reserved method name, cannot export a \"delete\" method");

    if ( strcmp(zcmd, "notify") == 0 )
        Tierror("reserved method name, cannot export a \"notify\" method");

    if ( strcmp(zcmd, "configure") == 0 )
        Tierror("reserved method name, cannot export a \"configure\" method");

    if ( strcmp(zcmd, "cget") == 0 )
        Tierror("reserved method name, cannot export a \"cget\" method");

    if ( strcmp(name, cur_module->name) == 0 )
        Tierror("cannot export a constructor method, use the \"constructor\" statement");

    if ( findMethod( cur_module->methods, name ) )
        Tierror("method previously defined");

    if ( findVar( cur_module->vars, name ) )
        Tierror("multiply declared member");

    cur_method = new Method(name, zcmd); 
    cur_member = cur_method;
    cur_module->methods.push_back(cur_method);
}

void constructor()
{
    cur_method = new Method( cur_module->name, "constructor");
    cur_member = cur_method;
    cur_module->methods.push_back(cur_method);
    cur_module->constructor = cur_method;
}

void arg( bool input, bool list, ArgType type, const char * name, ArgValue * value )
{
    cur_var = NULL;

    if ( (strcmp( cur_method->zcmd, "constructor" ) == 0) && input )
    {
        if ( strcmp(name, "session") == 0 )
            Tierror("reserved input constructor argument name, cannot use \"session\" argument");

        if ( strcmp(name, "db") == 0 )
            Tierror("reserved input constructor argument name, cannot use \"db\" argument");
    }

    if ( findArg( cur_method->args, name ) )
        Tierror("multiply declared argument");

    if ( (type == BOOL_ARG) && (list == true) )
        Tierror("bool type cannot be a list");

    cur_arg = new Arg(input, list, type, name); 
    cur_method->args.push_back(cur_arg);

    switch( type )
    {
        case INT_ARG:
        {
            if ( value == NULL )
            {
                cur_arg->value = strdup("0");
                break;
            }

            switch( value->type )
            {
                case NUM_INT:
                    cur_arg->value = value->value;
                    break;

                case NUM_DOUBLE:
                    Tierror("int cannot be assigned a float value");
                    cur_arg->value = value->value;
                    break;

                case QSTRING:
                    Tierror("int cannot be assigned a string value");
                    cur_arg->value = value->value;
                    break;

                case FALSE_K:
                    free( (void *) value->value );
                    cur_arg->value = strdup("0");
                    break;

                case TRUE_K:
                    free( (void *) value->value );
                    cur_arg->value = strdup("1");
                    break;

                case RECT_K:
                    Tierror("int cannot be assigned a rect value");
                    cur_arg->value = value->value;
                    break;

                case POINT_K:
                    Tierror("int cannot be assigned a point value");
                    cur_arg->value = value->value;
                    break;
            }
            break;
        }
        case FLOAT_ARG:
        {
            if ( value == NULL )
            {
                cur_arg->value = strdup("0.0");
                break;
            }

            switch( value->type )
            {
                case NUM_INT:
                    cur_arg->value = value->value;
                    break;

                case NUM_DOUBLE:
                    cur_arg->value = value->value;
                    break;

                case QSTRING:
                    Tierror("float cannot be assigned a string value");
                    cur_arg->value = value->value;
                    break;

                case FALSE_K:
                    Tierror("float cannot be assigned a bool value");
                    cur_arg->value = value->value;
                    break;

                case TRUE_K:
                    Tierror("float cannot be assigned a bool value");
                    cur_arg->value = value->value;
                    break;

                case RECT_K:
                    Tierror("float cannot be assigned a rect value");
                    cur_arg->value = value->value;
                    break;

                case POINT_K:
                    Tierror("float cannot be assigned a point value");
                    cur_arg->value = value->value;
                    break;
            }
            break;
        }
        case STRING_ARG:
        {
            if ( value == NULL )
            {
                cur_arg->value = strdup("");
                break;
            }

            switch( value->type )
            {
                case NUM_INT:
                    Tierror("string cannot be assigned a int value");
                    cur_arg->value = value->value;
                    break;

                case NUM_DOUBLE:
                    Tierror("string cannot be assigned a float value");
                    cur_arg->value = value->value;
                    break;

                case QSTRING:
                    cur_arg->value = value->value;
                    break;

                case FALSE_K:
                    Tierror("string cannot be assigned a bool value");
                    cur_arg->value = value->value;
                    break;

                case TRUE_K:
                    Tierror("string cannot be assigned a bool value");
                    cur_arg->value = value->value;
                    break;

                case RECT_K:
                    Tierror("string cannot be assigned a rect value");
                    cur_arg->value = value->value;
                    break;

                case POINT_K:
                    Tierror("string cannot be assigned a point value");
                    cur_arg->value = value->value;
                    break;
            }
            break;
        }
        case BOOL_ARG:
        {
            if ( value == NULL )
            {
                cur_arg->value = strdup("false");
                break;
            }

            switch( value->type )
            {
                case NUM_INT:
                    Tierror("bool cannot be assigned a int value");
                    cur_arg->value = value->value;
                    break;

                case NUM_DOUBLE:
                    Tierror("bool cannot be assigned a float value");
                    cur_arg->value = value->value;
                    break;

                case QSTRING:
                    Tierror("bool cannot be assigned a string value");
                    cur_arg->value = value->value;
                    break;

                case FALSE_K:
                    cur_arg->value = value->value;
                    break;

                case TRUE_K:
                    Tierror("bool can only be assigned a false value");
                    cur_arg->value = value->value;
                    break;

                case RECT_K:
                    Tierror("bool cannot be assigned a rect value");
                    cur_arg->value = value->value;
                    break;

                case POINT_K:
                    Tierror("bool cannot be assigned a point value");
                    cur_arg->value = value->value;
                    break;
            }
            break;
        }
        case DBOBJECT_ARG:
        {
            if ( value  )
            {
                Tierror("dbobject cannot be initialized to a default value");
                cur_arg->value = value->value;
            }
            else
                cur_arg->value = strdup("");

            break;
        }
        case ZOBJECT_ARG:
        {
            if ( value  )
            {
                Tierror("zobject cannot be initialized to a default value");
                cur_arg->value = value->value;
            }
            else
                cur_arg->value = strdup("");

            break;
        }
        case ICHANNEL_ARG:
        {
            if ( ! cur_arg->input  )
                Tierror("ichannel cannot be an out parameter");

            if ( value  )
            {
                Tierror("ichannel cannot be initialized to a default value");
                cur_arg->value = value->value;
            }
            else
                cur_arg->value = strdup("");

            break;
        }

        case OCHANNEL_ARG:
        {
            if ( ! cur_arg->input  )
                Tierror("ochannel cannot be an out parameter");

            if ( value  )
            {
                Tierror("ochannel cannot be initialized to a default value");
                cur_arg->value = value->value;
            }
            else
                cur_arg->value = strdup("");

            break;
        }

        case RECT_ARG:
        {
            if ( value  )
            {
                Tierror("rect cannot be initialized to a default value");
                cur_arg->value = value->value;
            }
            else
                cur_arg->value = strdup("");

            break;
        }

        case POINT_ARG:
        {
            if ( value  )
            {
                Tierror("rect cannot be initialized to a default value");
                cur_arg->value = value->value;
            }
            else
                cur_arg->value = strdup("");

            break;
        }
    }
}

void var( bool list, ArgType type, const char * name )
{
    cur_arg = NULL;

    if ( findVar( cur_module->vars, name ) )
        Tierror("multiply declared variable");

    if ( findMethod( cur_module->methods, name ) )
        Tierror("multiply declared member");

    if ( (type == BOOL_ARG) && (list == true) )
        Tierror("bool type cannot be a list");

    if( (type == ICHANNEL_ARG) || (type == OCHANNEL_ARG) )
        Tierror("Cannot export a channel variable");

    cur_var = new Var(list, type, name); 
    cur_member = cur_var;
    cur_module->vars.push_back(cur_var);
}

Arg * findArg( std::list<Arg *> & args, const char * arg_name )
{
    std::list<Arg *>::iterator itr;
    for( itr = args.begin(); itr != args.end(); ++itr )
    {
        Arg * a = *itr;

        if ( strcmp( a->name, arg_name ) == 0 )
            return a;
    }
    return NULL;
}

Var * findVar( std::list<Var *> & vars, const char * var_name )
{
    std::list<Var *>::iterator itr;
    for( itr = vars.begin(); itr != vars.end(); ++itr )
    {
        Var * a = *itr;

        if ( strcmp( a->name, var_name ) == 0 )
            return a;
    }
    return NULL;
}

bool duplicateNotify( const char * n )
{
    std::list<Var *>::iterator itr;

    for( itr = cur_module->vars.begin(); itr != cur_module->vars.end(); ++itr )
    {
        Var * a = *itr;

        if ( a->notify && strcmp( a->notify, n ) == 0 )
            return true;
    }
    return false;
}

Method * findMethod( std::list<Method *> & methods, const char * name )
{
    std::list<Method *>::iterator itr;
    for( itr = methods.begin(); itr != methods.end(); ++itr )
    {
        Method * m = *itr;

        if ( strcmp( m->name, name ) == 0 )
            return m;
    }
    return NULL;
}

void addValue( int ktype, const char * value )
{

}

inline int is_keyword( int type )
{
    return (type > KEYWORD_BASE);
}

%}

%union 
{
    const char * id;
    ArgType type;
    bool b;
    ArgValue value;
}

%token ID NUM_INT NUM_DOUBLE QSTRING
%token CCODE_BEGIN CCODE_LINE CCODE_END

%token KEYWORD_BASE
%token <type> INT_K
%token <type> FLOAT_K
%token <type> STRING_K
%token <type> BOOL_K
%token MODULE_K
%token IN_K
%token OUT_K
%token TRUE_K
%token FALSE_K
%token USAGE_K
%token EXPORT_K
%token CONSTRUCTOR_K
%token DBOBJECT_K
%token ZOBJECT_K
%token ICHANNEL_K
%token OCHANNEL_K
%token LIST_K
%token NOTIFY_K
%token RECT_K
%token POINT_K
%token DOC_K

%type <id> identifier
%type <id> qstring
%type <type> type
%type <b> argDir
%type <value> expression

%%

file
    :  /* nothing */
    |   modules
    |   ccode modules
    ;

ccode
    :   CCODE_BEGIN clines CCODE_END
    ;

clines
    :    /* nothing */
    |   clines CCODE_LINE { char * p = strdup(Ticcode); ccode.push_back(p); }
    ;

modules
    :   module
    |   DOC_K module { cur_module->doc.swap(doc); }
    |   modules module
    |   modules DOC_K module { cur_module->doc.swap(doc); }
    ;

module
    :    MODULE_K identifier { module($2,$2); } '{' members '}'
    |    MODULE_K identifier qstring { module($2,$3); } '{' members '}'
    ;

members
    :    /* nothing */
    |    members member
    |    members DOC_K member { cur_member->doc.swap(doc); }
    ;

member
    :    methodDef '(' args ')' ';'
    |    methodDef '(' ')' ';'
    |    methodDef '(' args ')' { ignore_error = true; } error { Tierror("missing ';'"); }
    |    methodDef '(' ')' { ignore_error = true; } error { Tierror("missing ';'"); }
    |    constructor '(' args ')' ';'
    |    constructor '(' ')' ';'
    |    varDef ';'
    ;

varDef
    :    EXPORT_K type identifier { var( false, $2, $3 ); } argOptions
    |    EXPORT_K LIST_K type identifier { var( true, $3, $4 ); } argOptions
    ;

constructor
    :    CONSTRUCTOR_K { constructor(); }
    ;

methodDef
    :    EXPORT_K identifier { method($2,$2); }
    |    EXPORT_K identifier qstring { method($2,$3); } 
    ;

args
    :    arg
    |    args ',' arg
    |    args { ignore_error = true; } error { Tierror("missing ','"); } arg
    ;

arg
    :    argDir decl argOptions {}
    ;

argDir
    : IN_K   { $$ = true; }
    | OUT_K  { $$ = false; }
    ;

decl
    : type identifier { arg( $<b>0, false, $1, $2, NULL); } 
    | LIST_K type identifier { arg( $<b>0, true, $2, $3, NULL); } 
    | type identifier '=' expression { arg( $<b>0, false, $1, $2, &$4 ); }
    | LIST_K type identifier '=' expression { Tierror("list type cannot be initialized"); }
    ; 

argOptions
    :    /* nothing */
    |    '[' options ']'
    ;

options
    :    /* nothing */
    |    options option ';'
    |    options option { ignore_error = true; } error { Tierror("missing ';'"); }
    ;

option
    :   USAGE_K '=' qstring  
        { 
            if ( cur_arg ) 
                cur_arg->usage = $3; 

            if ( cur_var ) 
                cur_var->usage = $3; 
        }
    |   NOTIFY_K '=' identifier  
        { 
            if ( cur_arg ) 
                Tierror("notify is not applicable to an method argument");

            if ( cur_var ) 
            {
                if ( duplicateNotify( $3 ) )
                    Tierror( "duplicate notify callback" );
                else
                    cur_var->notify = $3; 
            }
        }
    ;

type
    :    INT_K { $$ = INT_ARG; }
    |    FLOAT_K { $$ = FLOAT_ARG; }
    |    STRING_K { $$ = STRING_ARG; }
    |    BOOL_K { $$ = BOOL_ARG; }
    |    ZOBJECT_K { $$ = ZOBJECT_ARG; }
    |    DBOBJECT_K { $$ = DBOBJECT_ARG; }
    |    ICHANNEL_K { $$ = ICHANNEL_ARG; }
    |    OCHANNEL_K { $$ = OCHANNEL_ARG; }
    |    RECT_K { $$ = RECT_ARG; }
    |    POINT_K { $$ = POINT_ARG; }
    ;

expression
    :    NUM_INT    { $$.type = NUM_INT, $$.value = strdup(Titext); }
    |    NUM_DOUBLE { $$.type = NUM_DOUBLE, $$.value = strdup(Titext); }
    |    QSTRING    { $$.type = QSTRING; char * q = strdup(Titext+1); q[strlen(q)-1] = 0; $$.value = q; }
    |    FALSE_K    { $$.type = FALSE_K, $$.value = strdup(Titext); }
    |    TRUE_K     { $$.type = TRUE_K, $$.value = strdup(Titext); }
    ;

identifier
    :    ID { $$ = strdup(Titext); }
    |    { ignore_error = true; } error 
         {
             if ( is_keyword(Tichar) )
             {
#if YYDEBUG
                printf("KID (%s)\n", Titext );
#endif
                 yyerrok; 
                 yyclearin; 
                 $$ = strdup(Titext);
             }
             else
             {
                 ignore_error = false;
                 Tierror("parse error");
             }
         }
    ;

qstring
    :    QSTRING    { char * q = strdup(Titext+1); q[strlen(q)-1] = 0; $$ = q; }
    ;

%%

void Tierror( const char * msg )
{
    if ( ignore_error )
    {
        ignore_error = false;
        return;
    }

    fprintf( stderr, "%s:%d: %s, reading %s\n", Tiinfile, Tilex_lineno, msg, Titext);
    Tierrors++;
}
