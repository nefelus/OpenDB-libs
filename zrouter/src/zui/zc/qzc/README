This directory contains the implementation of the ZC canvas using QT


object | setContext            refresh foo
       | -----------> GLOBAL    ---->  GLDISPLLIST
list   |              DISPL
                      LIST

tkqt.so introduces the following concepts:

1. AREA (context): where objects are drawan. It is created by:
	qt NewArea

2. WINDOW: where an area is "bound". An area is only bound to one window:
	qt newWindow area windowid
The window needs to be created, and it should be visible first.

3. DATASETS identified by their tag, created by:
	qt addObject tag descr
	set cnt [qt readFile tag] - cnt = number of objects in that dataset

descr is the object description like:
	id ID bb {x0 y0 x1 y1} type TYPE hierarchy HIERARCHY layer LAYER x X (*)


In the case of streaming, a modified data format is used, which compresses
the information. The identifiers are dropped for the first 4 items which are
common to (almost) all, and the id field is dropped entirely. These are:
layer, hierarchy, type and bbox. Thus, the item described by (*) would be
sent as:
LAYER HIERARCHY TYPE {x0 y1 x1 y1} x X

"x" in (*) is an "extension" of the basic data items.
Currently, x can be one of:
tag, mark, dd (see 13.), color (see 12.)
tag and mark may have multiple instances within the same item - values are
then aggregated.

A valid "extension" set of values might look like:
tag abc mark def color white tag xyz mark ddd dd {x1 y1 x2 y2 x3 y3}
This would result in this item having a tag value of: "abc xyz"
This would result in this item having a mark value of: "def ddd"
color: white
dd: {x1 y1 x2 y2 x3 y3}


A dataset can be erased using:

        qt eraseDataset tag

The bbox of data set can be obtained by
	qt getDataBBox tag

    qt getDatasetStats tag returns count of items in a dataset

    qt getDataSetData tag returns a list containing all of the data items
       in dataset tag, in the original "addObject" format. 
    CAVEAT: object ids are NOT recreated - they are all 0.

4. DISPLAY LISTS. A set of objects (identified by its tag) can be "drawn"
on an area context using:
	qt setDataset $WID tag xoffset yoffset
    xoffset, yoffset in WORLD coordinates

To clear the display list, we use: 
	qt setDataset $WID ""

5. a. REFRESH: a method to cause the LOCAL display list to be drawn to the
      area: set cnt [qt refresh area] - cnt = number of objects drawn
   b. RefreshSelection: causes the selection to be set/unset on top of the 
      ALREADY RENDERED area: qt refreshSelection area
      -call when adding/removing a selection insted of refresh, and will not
       require the entire picture to be redrawn
      -needs PAINT called afterwards

6. PAINT: to transfer the area to the window bound:
	qt paint area

7. FILTERING: since each object has type, hierachy and layer
it can be filtered by layer:
	qt setLayerStatus layer 0|1

or by other tags:

	qt setTagStatus type|hierarchy tag 0|1

	qt setTagStatus htype a/b 0|1

8. SELECTION: a selection object can be drawn on some layer
in a more efficient way, so changing the selection can be
faster. A selection is created just like any other object list:

	qt addObject seltag descr

then it is defined using:
	qt setSelection area tag

while its color attributes are specifed with:
	qt setSelPen width color

9. IMAGES

The canvas displays TCL images (image create photo) placed on
the zcanvas:
    qt addImage tag image [string length $image] x0 y0 x1 y1 [format]
    qt addImage64 tag image [string length $image] x0 y0 x1 y1 [format]
    qt addImageChannel tag channel x0 y0 x1 y1

The bbox is in world coordinates - image will be scaled as needed.  

tag names the image. 

format is optional for addImage/addImage64 and specifies the image format.
addImage should work just fine without it in almost all cases.

"setImage" and "eraseImage" are analogous to "setDataset" and
"eraseDataset" and create an "image display list". 

Images are scaled appropriately on canvas, depending on the setBBox command.

An area can render both images and datasets together. Images are rendered
FIRST (via bitblt) - in the order in which they are added to the "image
list", THEN any dataset is drawn on top.

Images do NOT support any sort of alpha channel blending at the moment - but
that may be possible in the future.

qt grabImage renderarea tag 
will capture the current (non-selection) display pixmap of the given
renderarea and turn it into a global image useable by any area, named tag.

qt setImageBBox tag allows for resetting of the bbox associate with image
tag.

10. SCROLLING/OVERSAMPLING

Note: ALL these methods take a render area as their first argument

The canvas can render to an internal buffer larger than the display window
(in effect, the canvas can be a window on a larger bitmap).
    -setScaleFactor(double x, double y); 
        -sets the x and y scale factors in terms of "expansion"
            -1.0 means, bitmap = window size
            -1.5 means, bitmap = 1.5 x window size

The canvas can scroll around the oversampled area (see above) by setting an
offset compared to the "center" of the bbox
    -scroll(dx, dy): dx = delta x in PIXELS, dy = delta y IN PIXELS
        -dx, dy are relative to CURRENT scroll offsets
    -resetScroll(): resets absolute offsets to 0,0

If the scroll settings causes the image to display an area where there is no
data, the "overscan" color will be used to display this image. 
    -setOverscanColor(char *x) sets a color for the non-data portion of an
     image


11. Arrows

The gui renders items of type "larrow" and "rarrow" (left and right arrows)
in a special way. If the coordinates are: (x0,y) and (x1,y), then:

x0              x1
---------------->
    rarrow

<----------------
    larrow
                                
Arrows are rotated as needed.

{ id x.xxx type rarrow hierarchy inst bb {x0 y0 x1 y1} layer 1 color blue }

Note: arrows are not properly accounted for in the "getDataBBox" method


12. Special colors

    Currently, items NOT in the following type list:
    -vias
    -signal wires
    -polygons
    
    are checked for a "color" attribute. This allows a given item to be
    rendered with a special color, different from the normal color for its
    layer.

    This includes arrows, bbox, inst, pin, etc.

    If the value of the color attribute is numeric, it is taken to be an
    index into a "special" colormap installed for that rendering context.
    Those values are set with setBrush/setPen. The index is used as a layer
    number for that lookup. If the color attribute is alphanumeric, it is
    taken to be a "named" color such as "white" or "green4".

    The special Colormap is set with: setSepcialColormap WID tag
    
    For information about working with colormaps, see 14.

13. Polygons
   
   Polygons (arbitrary shapes) can be specified via the "dd" attribute,
   which specifies a set of points specific to the item "type".

   Currently, any item which defined a "dd" attribute is treated as a
   polygon, and a closed, filled shape is drawn connecting the points
   specified via dd.

   Note: in streaming mode, a polygon still needs a bbox attribute, which
   will be {0 0 0 0}. In non-streaming mode, a bbox is not required.


14. Colormaps

    Each rendering context has a "regular" colormap and a "special"
    colormap. The regular map specifies the colors for items on a given
    layer. The special map defines alternate colors. Although the special
    map uses the "layer" indexing method, these items can be on any level,
    and simply by specifying "color 3", will use the color defined by layer
    3 of the special map for that object.

    To work with colormaps, a "selectColormap" command exists, which will
    then allow setBrush and setPen to work on that colormap, regardless of
    which rendering context(s) that area has been assigned to.

    Currently, all the area-specific commands do the appropriate
    selectColormap already. This means it is backwards compatible with the
    old method.

    For instance, the "setSelectionPen" method of zc_qt.tcl does:
    selectColormap cmap_$WID
    setSelPen $WID $width $color

    Note: the $WID is no longer necessary here, but will be required for
    now, and will just be ignored.

15. Labels

    Each object can include the optional "label" attribute, which specifies
    a label to be attached to the item. Successive "label" attributes stack
    and are separated by newlines (i.e. appear on separate lines). If a
    label value contains a space, it must be enclosed by { }. 
    e.g.: label {abc def} label 123 label more

    If an object has a label attribute, it may have an lbbox attribute,
    which specifies a bbox for rendering the text into. If the text is
    larger than the lbbox, an attempt is made to resize the font in
    increments of 1 down to pixel size 4 in order to fit the text into the
    lbbox. If the text still doesn't fit, the text will be rendered at size
    4. No UPSIZING of fonts is currently done.

    In general, labels are displayed right-to-left. If an lbbox is not
    specified, for items wider than high, text is displayed below the item
    (centered if the text takes less room than the width of the item). If
    the lbbox is not specified and item is higher than wide (vertical wire,
    for example), the text is displayed to the right of the item, 
    
    Labels for arrows are rotated to align with the direction of the shaft
    of the arrow (but only up to 90 degrees).
